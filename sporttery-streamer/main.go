package main

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/chromedp/cdproto/emulation"
	"github.com/chromedp/cdproto/network"
	"github.com/chromedp/chromedp"
	"github.com/go-co-op/gocron"

	"github.com/joho/godotenv"
	"github.com/redis/go-redis/v9"
)

var (
	ctx = context.Background()

	// Áªü‰∏Ä TTL ‰∏é Stream Ê∞¥‰Ωç
	ttl54h       = 54 * time.Hour
	streamMaxLen = int64(120)

	redisClient *redis.Client

	// ÊµèËßàÂô®ÂèëÁé∞/ËøûÊé•
	chromeDiscovery string
	chromeWS        string
	discoveryClient *http.Client
)

/* ======================= ÁéØÂ¢É/ÂàùÂßãÂåñ ======================= */

func getenv(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

func mustAtoiEnv(envKey, def string) int {
	if v := os.Getenv(envKey); v != "" {
		if n, err := strconv.Atoi(v); err == nil {
			return n
		}
	}
	n, _ := strconv.Atoi(def)
	return n
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func newRedisClient() *redis.Client {
	host := getenv("REDIS_HOST", "redis-15892.c273.us-east-1-2.ec2.redns.redis-cloud.com")
	port := mustAtoiEnv("REDIS_PORT", "15892")
	user := getenv("REDIS_USER", "default")
	pass := getenv("REDIS_PASS", "")

	// ÊòæÂºèÈÖçÁΩÆ‰ºòÂÖàÔºõÂê¶ÂàôÊåâÂ∏∏ËØÜÊé®Êñ≠
	tlsEnv := strings.TrimSpace(os.Getenv("REDIS_TLS"))
	useTLS := false
	if tlsEnv != "" {
		useTLS = strings.EqualFold(tlsEnv, "true")
	} else if port == 6380 || strings.HasPrefix(host, "rediss://") {
		useTLS = true
	}

	addr := fmt.Sprintf("%s:%d", host, port)
	opts := &redis.Options{
		Addr:         addr,
		Username:     user,
		Password:     pass,
		DB:           0,
		DialTimeout:  5 * time.Second,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 5 * time.Second,
	}
	if useTLS {
		opts.TLSConfig = &tls.Config{MinVersion: tls.VersionTLS12}
	}

	rdb := redis.NewClient(opts)
	if err := rdb.Ping(ctx).Err(); err != nil {
		log.Fatalf("‚ùå Redis ËøûÊé•Â§±Ë¥•: %v (addr=%s tls=%v)", err, addr, useTLS)
	}
	log.Printf("‚úÖ Â∑≤ËøûÊé• Redis: %s (TLS=%v)\n", addr, useTLS)
	return rdb
}

func init() {
	_ = godotenv.Load(".env") // ÂèØÈÄâÔºöËØªÂèñÂΩìÂâçÁõÆÂΩïÁöÑ .env

	rand.Seed(time.Now().UnixNano())
	log.SetFlags(log.LstdFlags | log.Lmsgprefix)
	log.SetPrefix("[fetcher] ")

	redisClient = newRedisClient()

	chromeDiscovery = strings.TrimSpace(getenv("CHROME_DISCOVERY", "http://chrome:9222/json/version"))
	chromeWS = strings.TrimSpace(os.Getenv("CHROME_WS"))

	// ÂèëÁé∞ DevTools ÁöÑ‰∏ìÁî® HTTP ÂÆ¢Êà∑Á´ØÔºàÁ¶ÅÁî®‰ª£ÁêÜÔºåÁü≠Ë∂ÖÊó∂Ôºâ
	discoveryTransport := &http.Transport{
		Proxy: nil, // Á¶ÅÁî®ÁéØÂ¢É‰ª£ÁêÜÔºåÈÅøÂÖç 9222 traffic Ëµ∞Á≥ªÁªü‰ª£ÁêÜ
		DialContext: (&net.Dialer{
			Timeout:   5 * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
		TLSClientConfig: &tls.Config{MinVersion: tls.VersionTLS12},
	}
	discoveryClient = &http.Client{
		Timeout:   8 * time.Second,
		Transport: discoveryTransport,
	}

	log.Printf("üåê Chrome discovery=%s ws_override=%q\n", chromeDiscovery, chromeWS)
}

/* ======================= Êï∞ÊçÆÁªìÊûÑ/Â∑•ÂÖ∑ ======================= */

type OutputData struct {
	LotteryNumber struct {
		MatchNumStr string `json:"matchNumStr"`
		SellStatus  string `json:"sellStatus"`
		TaxDateNo   string `json:"taxDateNo"`
		MatchID     string `json:"taxDateNo+matchNumStr_lastnm"`
	} `json:"Lottery_Number"`
	MatchInfo struct {
		League    string `json:"league"`
		HomeTeam  string `json:"home_team"`
		AwayTeam  string `json:"away_team"`
		DateTime  string `json:"date_time"`
		MatchTime string `json:"matchTime"`
	} `json:"match_info"`
	GoalLine string `json:"goal_line,omitempty"`
}

func toString(v any) string {
	switch t := v.(type) {
	case string:
		return t
	case float64:
		// ÊØîËµõÂè∑Á≠âÊï¥Êï∞Â≠óÊÆµ
		if t == float64(int64(t)) {
			return fmt.Sprintf("%.0f", t)
		}
		return strconv.FormatFloat(t, 'f', -1, 64)
	default:
		return ""
	}
}

func safeMatchID(taxDateNo, matchNumStr string) string {
	s := matchNumStr
	if len(s) > 3 {
		s = s[len(s)-3:]
	}
	return taxDateNo + s
}

func parseCNTime(loc *time.Location, date, tm string) (time.Time, error) {
	layouts := []string{"2006-01-02 15:04:05", "2006-01-02 15:04"}
	var last error
	for _, l := range layouts {
		if ts, err := time.ParseInLocation(l, date+" "+tm, loc); err == nil {
			return ts, nil
		} else {
			last = err
		}
	}
	return time.Time{}, last
}

/* ======================= DevTools Ëá™Âä®ÂèëÁé∞ ======================= */

func discoverChromeWS() (string, error) {
	base := chromeDiscovery
	if base == "" {
		base = "http://chrome:9222/json/version"
	}

	// Ëß£Êûê chrome ÂÆπÂô®ÁöÑ IPÔºàÂÖúÂ∫ïÁõ¥ËøûÔºâ
	ip := ""
	if addrs, err := net.LookupHost("chrome"); err == nil && len(addrs) > 0 {
		ip = addrs[0]
	}

	type probe struct {
		URL       string
		HostHdr   string
		ParseMode string
		Label     string
	}

	var probes []probe

	// /json/version Â∏∏ËßÑÊé¢Êµã
	versionURL := strings.Replace(base, "127.0.0.1:9222", "chrome:9222", 1)
	probes = append(probes, probe{
		URL:       versionURL,
		ParseMode: "version",
		Label:     "version@chrome",
	})
	probes = append(probes, probe{
		URL:       versionURL,
		HostHdr:   "127.0.0.1:9222",
		ParseMode: "version",
		Label:     "version@chrome host=127.0.0.1",
	})

	// /json ÂàóË°®ÂÖúÂ∫ï
	jsonList := strings.Replace(versionURL, "/json/version", "/json", 1)
	if jsonList == versionURL {
		jsonList = "http://chrome:9222/json"
	}
	probes = append(probes, probe{
		URL:       jsonList,
		ParseMode: "list",
		Label:     "list@chrome",
	})
	probes = append(probes, probe{
		URL:       jsonList,
		HostHdr:   "127.0.0.1:9222",
		ParseMode: "list",
		Label:     "list@chrome host=127.0.0.1",
	})

	// Ëã•Ëß£ÊûêÂà∞ IPÔºåÂÜçÂ∞ùËØïÁî® IP Áõ¥Ëøû
	if ip != "" {
		ipVersion := strings.Replace(versionURL, "chrome:9222", ip+":9222", 1)
		ipList := strings.Replace(jsonList, "chrome:9222", ip+":9222", 1)

		probes = append(probes, probe{
			URL:       ipVersion,
			ParseMode: "version",
			Label:     "version@ip",
		})
		probes = append(probes, probe{
			URL:       ipVersion,
			HostHdr:   "127.0.0.1:9222",
			ParseMode: "version",
			Label:     "version@ip host=127.0.0.1",
		})
		probes = append(probes, probe{
			URL:       ipList,
			ParseMode: "list",
			Label:     "list@ip",
		})
		probes = append(probes, probe{
			URL:       ipList,
			HostHdr:   "127.0.0.1:9222",
			ParseMode: "list",
			Label:     "list@ip host=127.0.0.1",
		})
	}

	do := func(p probe) ([]byte, int, error) {
		req, _ := http.NewRequest("GET", p.URL, nil)
		req.Header.Set("Accept", "application/json")
		if p.HostHdr != "" {
			req.Host = p.HostHdr
			req.Header.Set("Host", p.HostHdr)
		}
		resp, err := discoveryClient.Do(req)
		if err != nil {
			return nil, 0, err
		}
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1<<20))
		return body, resp.StatusCode, nil
	}

	var lastErr error
	for round := 0; round < 3; round++ {
		for _, p := range probes {
			body, code, err := do(p)
			if err != nil {
				lastErr = fmt.Errorf("%s -> request error: %w", p.Label, err)
				continue
			}
			if code < 200 || code >= 300 {
				lastErr = fmt.Errorf("%s -> http %d body=%q", p.Label, code, string(body[:min(120, len(body))]))
				continue
			}

			switch p.ParseMode {
			case "version":
				var vr map[string]any
				if err := json.Unmarshal(body, &vr); err != nil {
					lastErr = fmt.Errorf("%s decode json: %v", p.Label, err)
					continue
				}
				if ws, _ := vr["webSocketDebuggerUrl"].(string); ws != "" {
					if ip != "" {
						ws = strings.ReplaceAll(ws, ip+":9222", "chrome:9222")
					}
					ws = strings.ReplaceAll(ws, "127.0.0.1:9222", "chrome:9222")
					return ws, nil
				}
				lastErr = fmt.Errorf("%s no webSocketDebuggerUrl", p.Label)

			case "list":
				var arr []map[string]any
				if err := json.Unmarshal(body, &arr); err != nil {
					lastErr = fmt.Errorf("%s decode json: %v", p.Label, err)
					continue
				}
				for _, it := range arr {
					if typ, _ := it["type"].(string); typ == "browser" {
						if ws, _ := it["webSocketDebuggerUrl"].(string); ws != "" {
							if ip != "" {
								ws = strings.ReplaceAll(ws, ip+":9222", "chrome:9222")
							}
							ws = strings.ReplaceAll(ws, "127.0.0.1:9222", "chrome:9222")
							return ws, nil
						}
					}
				}
				lastErr = fmt.Errorf("%s list has no browser entry", p.Label)
			}
		}
		backoff := time.Duration(400*(1<<round)) * time.Millisecond
		time.Sleep(backoff)
	}

	if lastErr == nil {
		lastErr = errors.New("discovery exhausted without specific error")
	}
	return "", lastErr
}

/* ======================= ÈÄöËøáÊµèËßàÂô®Âèñ JSON ======================= */
func chromeFetchJSON(c context.Context, wsURL, apiURL string, timeout time.Duration) ([]byte, error) {
	if wsURL == "" {
		return nil, errors.New("chromeFetchJSON: empty wsURL")
	}
	if apiURL == "" {
		return nil, errors.New("chromeFetchJSON: empty apiURL")
	}

	// ËøûÊé•Âà∞ËøúÁ®ã ChromeÔºàÂÆπÂô®ÈáåÁöÑ headless-shellÔºâ
	allocCtx, cancelAlloc := chromedp.NewRemoteAllocator(c, wsURL)
	defer cancelAlloc()
	taskCtx, cancelTask := chromedp.NewContext(allocCtx)
	defer cancelTask()

	if timeout <= 0 {
		timeout = 35 * time.Second
	}
	ctx, cancel := context.WithTimeout(taskCtx, timeout)
	defer cancel()

	// Áªü‰∏Ä UAÔºàÁßªÂä®Á´ØÔºâ
	const ua = "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Mobile Safari/537.36 Edg/141.0.0.0"
	extraHeaders := network.Headers{
		"Accept":          "application/json, text/javascript, */*; q=0.01",
		"Accept-Language": "zh-CN,zh;q=0.9",
		"Cache-Control":   "no-cache",
		"Pragma":          "no-cache",
		"Origin":          "https://m.sporttery.cn",
		"Referer":         "https://m.sporttery.cn/",
	}

	if err := chromedp.Run(ctx,
		network.Enable(),
		emulation.SetUserAgentOverride(ua),
		network.SetExtraHTTPHeaders(extraHeaders),
	); err != nil {
		return nil, err
	}

	bodyCh := make(chan []byte, 1)
	errCh := make(chan error, 1)
	timer := time.NewTimer(timeout)
	defer timer.Stop()

	var targetReq network.RequestID
	chromedp.ListenTarget(taskCtx, func(ev interface{}) {
		switch ev := ev.(type) {
		case *network.EventResponseReceived:
			if targetReq == "" && strings.HasPrefix(ev.Response.URL, apiURL) {
				targetReq = ev.RequestID
			}
		case *network.EventLoadingFinished:
			if targetReq != "" && ev.RequestID == targetReq {
				body, err := network.GetResponseBody(ev.RequestID).Do(taskCtx)
				if err != nil {
					select {
					case errCh <- err:
					default:
					}
					return
				}
				select {
				case bodyCh <- body:
				default:
				}
			}
		case *network.EventLoadingFailed:
			if targetReq != "" && ev.RequestID == targetReq {
				select {
				case errCh <- errors.New(ev.ErrorText):
				default:
				}
			}
		}
	})

	// È¢ÑÁÉ≠Âà∞Á©∫ÁôΩÈ°µÔºåÈÅøÂÖçÁ´ôÁÇπËÑöÊú¨ÂèëËµ∑Êó†ÂÖ≥ XHR/CORS Âô™Â£∞
	if err := chromedp.Run(ctx,
		chromedp.Navigate("about:blank"),
	); err != nil {
		return nil, fmt.Errorf("warmup navigate failed: %w", err)
	}

	if err := chromedp.Run(ctx,
		chromedp.Navigate(apiURL),
	); err != nil {
		return nil, fmt.Errorf("navigate api failed: %w", err)
	}

	var (
		body    []byte
		waitErr error
	)

	select {
	case body = <-bodyCh:
	case waitErr = <-errCh:
	case <-timer.C:
	case <-ctx.Done():
		waitErr = ctx.Err()
	}

	if len(body) > 0 {
		return body, nil
	}
	if waitErr != nil {
		msg := waitErr.Error()
		if strings.Contains(msg, "invalid context") || strings.Contains(msg, "target closed") {
			log.Printf("‚ÑπÔ∏è network body capture fallback: %v", waitErr)
		} else {
			return nil, fmt.Errorf("network body capture failed: %w", waitErr)
		}
	}
	if err := ctx.Err(); err != nil && !errors.Is(err, context.DeadlineExceeded) {
		return nil, fmt.Errorf("wait response failed: %w", err)
	}

	var pre string
	fallbackCtx, cancelNav := context.WithTimeout(taskCtx, 10*time.Second)
	defer cancelNav()

	if err := chromedp.Run(fallbackCtx,
		chromedp.WaitVisible("pre", chromedp.ByQuery),
		chromedp.Text("pre", &pre, chromedp.ByQuery),
	); err != nil {
		return nil, fmt.Errorf("fetch via JS failed and no <pre> fallback: %w | network_body_empty", err)
	}

	return []byte(pre), nil
}


/* ======================= ‰∏öÂä°ÊäìÂèñÔºàÂÖ®Ëµ∞ÊµèËßàÂô®ÂÆπÂô®Ôºâ ======================= */

func fetchMatches() ([]OutputData, error) {
	target := "https://webapi.sporttery.cn/gateway/uniform/football/getMatchCalculatorV1.qry?poolCode=&channel=c"

	// 1) Ëé∑Âèñ DevTools WSÔºàÊîØÊåÅÁî±ÁéØÂ¢ÉÊåáÂÆöÔºåÂ§±Ë¥•Ëá™Âä®ÂèëÁé∞Ôºâ
	if chromeWS == "" {
		ws, err := discoverChromeWS()
		if err != nil {
			return nil, fmt.Errorf("devtools discover failed: %w", err)
		}
		chromeWS = ws
		log.Printf("üåê DevTools WS = %s", chromeWS)
	}

	// 2) ÈÄöËøáÊµèËßàÂô®Êäì
	start := time.Now()
	raw, err := chromeFetchJSON(ctx, chromeWS, target, 35*time.Second)
	if err != nil {
		log.Printf("‚ö†Ô∏è browser fetch failed: %v; rediscovering DevTools‚Ä¶", err)
		chromeWS = ""
		ws, derr := discoverChromeWS()
		if derr != nil {
			return nil, fmt.Errorf("browser fetch failed: %v (rediscover err=%v)", err, derr)
		}
		chromeWS = ws
		log.Printf("üåê DevTools WS refreshed: %s", chromeWS)
		start = time.Now()
		raw, err = chromeFetchJSON(ctx, chromeWS, target, 35*time.Second)
	}
	if err != nil {
		return nil, fmt.Errorf("browser fetch failed after rediscover: %w", err)
	}
	log.Printf("‚úÖ 200 OK via browser, cost=%s len=%d", time.Since(start), len(raw))

	// 3) Ëß£Êûê JSON
	var root map[string]any
	if err := json.Unmarshal(raw, &root); err != nil {
		// Â¶ÇÈÅáÈùû JSONÔºåÊääÂâç 200 Â≠óÁ¨¶ÊâìÂç∞Âá∫Êù•ËæÖÂä©ÂÆö‰Ωç
		s := string(raw)
		if len(s) > 200 {
			s = s[:200]
		}
		return nil, fmt.Errorf("JSON Ëß£ÊûêÂ§±Ë¥•: %w | head=%q", err, s)
	}

	value, ok := root["value"].(map[string]any)
	if !ok {
		log.Println("‚ö†Ô∏è Êó† value Â≠óÊÆµÔºåÂèØËÉΩÂÅúÂîÆ/Á©∫Ê°£Êúü")
		return []OutputData{}, nil
	}
	rawList, exists := value["matchInfoList"]
	if !exists {
		log.Println("‚ö†Ô∏è Êó† matchInfoList")
		return []OutputData{}, nil
	}
	arr, ok := rawList.([]any)
	if !ok {
		log.Println("‚ö†Ô∏è matchInfoList Á±ªÂûãÂºÇÂ∏∏")
		return []OutputData{}, nil
	}

	res := make([]OutputData, 0)
	for _, m := range arr {
		subs, ok := m.(map[string]any)["subMatchList"].([]any)
		if !ok {
			continue
		}
		for _, s := range subs {
			sm := s.(map[string]any)
			var out OutputData
			out.LotteryNumber.MatchNumStr = toString(sm["matchNumStr"])
			out.LotteryNumber.SellStatus = toString(sm["sellStatus"])
			out.LotteryNumber.TaxDateNo = toString(sm["taxDateNo"])
			out.LotteryNumber.MatchID = safeMatchID(out.LotteryNumber.TaxDateNo, out.LotteryNumber.MatchNumStr)

			out.MatchInfo.League = toString(sm["leagueAllName"])
			out.MatchInfo.HomeTeam = toString(sm["homeTeamAllName"])
			out.MatchInfo.AwayTeam = toString(sm["awayTeamAllName"])
			out.MatchInfo.DateTime = toString(sm["matchDate"])
			out.MatchInfo.MatchTime = toString(sm["matchTime"])

			if hhad, ok := sm["hhad"].(map[string]any); ok {
				out.GoalLine = toString(hhad["goalLineValue"])
			}
			res = append(res, out)
		}
	}
	return res, nil
}

/* ======================= Redis ÂÜôÂÖ•/ÁõëÊéß ======================= */

func pushToStream(m OutputData, ts int64) error {
	id, err := redisClient.XAdd(ctx, &redis.XAddArgs{
		Stream: "new_matches_stream",
		MaxLen: streamMaxLen,
		Approx: true,
		Values: map[string]any{
			"match_id":    m.LotteryNumber.MatchID,
			"timestamp":   ts,
			"home_team":   m.MatchInfo.HomeTeam,
			"away_team":   m.MatchInfo.AwayTeam,
			"league":      m.MatchInfo.League,
			"datetime":    m.MatchInfo.DateTime,
			"match_time":  m.MatchInfo.MatchTime,
			"goal_line":   m.GoalLine,
			"sell_status": m.LotteryNumber.SellStatus,
		},
	}).Result()
	if err != nil {
		return fmt.Errorf("XADD Â§±Ë¥•: %w", err)
	}
	fmt.Printf("üöÄ Stream Êé®ÈÄÅ: %s -> %s\n", m.LotteryNumber.MatchID, id)
	return nil
}

func storeReadableIndex(m OutputData) error {
	norm := func(s string) string { return strings.TrimSpace(s) }
	key := fmt.Sprintf("match_index:%s:%s:%s",
		norm(m.MatchInfo.HomeTeam), norm(m.MatchInfo.AwayTeam), m.LotteryNumber.MatchNumStr)
	val := map[string]any{
		"match_id":  m.LotteryNumber.MatchID,
		"date":      m.MatchInfo.DateTime,
		"time":      m.MatchInfo.MatchTime,
		"goal_line": m.GoalLine,
		"home":      m.MatchInfo.HomeTeam,
		"away":      m.MatchInfo.AwayTeam,
	}
	if err := redisClient.HSet(ctx, key, val).Err(); err != nil {
		return fmt.Errorf("HSET %s Â§±Ë¥•: %w", key, err)
	}
	_ = redisClient.Expire(ctx, key, ttl54h).Err()
	fmt.Printf("üìå ÂèØËØªÁ¥¢Âºï: %s -> %+v\n", key, val)
	return nil
}

func storeToRedis(matches []OutputData) {
	loc, _ := time.LoadLocation("Asia/Shanghai")

	for _, m := range matches {
		id := m.LotteryNumber.MatchID
		if id == "" {
			continue
		}
		t, err := parseCNTime(loc, m.MatchInfo.DateTime, m.MatchInfo.MatchTime)
		if err != nil {
			log.Printf("‚ùå Êó∂Èó¥Ëß£ÊûêÂ§±Ë¥•Ôºö%s %s (%v)", m.MatchInfo.DateTime, m.MatchInfo.MatchTime, err)
			continue
		}
		ts := t.Unix()

		ok, err := redisClient.SetNX(ctx, "match_id:"+id, "1", ttl54h).Result()
		if err != nil {
			log.Printf("‚ùå SetNX Â§±Ë¥• match_id:%s: %v", id, err)
			continue
		}
		if !ok {
			continue // ‰∏çÊòØÊñ∞Â¢ûÔºåË∑≥Ëøá
		}

		if err := redisClient.ZAdd(ctx, "match_schedule", redis.Z{
			Score:  float64(ts),
			Member: id,
		}).Err(); err != nil {
			log.Printf("‚ùå ZADD Â§±Ë¥• %s: %v", id, err)
		}

		if err := pushToStream(m, ts); err != nil {
			log.Printf("‚ùå Stream Êé®ÈÄÅÂ§±Ë¥• %s: %v", id, err)
		}

		if err := storeReadableIndex(m); err != nil {
			log.Printf("‚ö†Ô∏è ÂèØËØªÁ¥¢ÂºïÂÜôÂÖ•Â§±Ë¥• %s: %v", id, err)
		}

		fmt.Printf("‚úÖ Êñ∞Â¢ûÊØîËµõÔºö%s  Êó∂Èó¥Êà≥Ôºö%d\n", id, ts)
	}

	// Ê∏ÖÁêÜ 72h ÂâçÁöÑÊó∂Èó¥Á¥¢ÂºïÔºõÂπ∂Á°Æ‰øùÊµÅ‰∏çË∂ÖËøá 120
	cutoff := float64(time.Now().Add(-72 * time.Hour).Unix())
	_ = redisClient.ZRemRangeByScore(ctx, "match_schedule", "0", strconv.FormatFloat(cutoff, 'f', -1, 64)).Err()
	_ = redisClient.XTrimMaxLen(ctx, "new_matches_stream", streamMaxLen).Err()
}

func initStreamConsumerGroup() {
	if err := redisClient.XGroupCreateMkStream(ctx, "new_matches_stream", "match_processors", "0").Err(); err != nil &&
		!strings.Contains(err.Error(), "BUSYGROUP") {
		log.Printf("‚ö†Ô∏è ÂàõÂª∫Ê∂àË¥πÁªÑÂ§±Ë¥•: %v", err)
		return
	}
	log.Println("‚úÖ Ê∂àË¥πÁªÑ 'match_processors' Â∞±Áª™")
}

func printStreamStats() {
	info, err := redisClient.XInfoStream(ctx, "new_matches_stream").Result()
	if err != nil {
		if strings.Contains(err.Error(), "No such key") {
			log.Println("‚ÑπÔ∏è Stream Â∞öÊó†Êï∞ÊçÆ")
			return
		}
		log.Printf("‚ö†Ô∏è Ëé∑Âèñ Stream ‰ø°ÊÅØÂ§±Ë¥•: %v", err)
		return
	}
	fmt.Printf("üìä Stream: len=%d groups=%d last-id=%s\n", info.Length, info.Groups, info.LastGeneratedID)
}

func debugRedisData() {
	it := redisClient.Scan(ctx, 0, "match_index:*", 3).Iterator()
	fmt.Println("üîé ÈááÊ†∑ match_index:*")
	for it.Next(ctx) {
		k := it.Val()
		vals, _ := redisClient.HGetAll(ctx, k).Result()
		fmt.Printf(" - %s => %+v\n", k, vals)
	}
	if err := it.Err(); err != nil {
		log.Printf("‚ö†Ô∏è SCAN Âá∫Èîô: %v", err)
	}
	zs, _ := redisClient.ZRangeWithScores(ctx, "match_schedule", 0, 2).Result()
	fmt.Printf("‚è±  match_schedule Ââç3: %+v\n", zs)
	printStreamStats()
}

/* ======================= Ë∞ÉÂ∫¶ ======================= */

func scheduledTask(fast bool) {
	// Âú® 3 ÂàÜÈíü Cron Âü∫Á°Ä‰∏äÔºåÈ¢ùÂ§ñÂ¢ûÂä† 60‚Äì90 ÁßíÈöèÊú∫Âª∂Ëøü
	delay := time.Duration(60+rand.Intn(31)) * time.Second
	fmt.Printf("[%s] [%s] È¢ùÂ§ñÂª∂Ëøü %s ÂêéÂºÄÂßãÊäìÂèñ...\n",
		time.Now().Format("15:04:05"),
		map[bool]string{true: "È´òÈ¢ë", false: "Â∏∏ËßÑ"}[fast],
		delay)
	time.Sleep(delay)

	res, err := fetchMatches()
	if err != nil {
		log.Printf("ÊäìÂèñÂ§±Ë¥•: %v\n", err)
		return
	}
	if len(res) > 0 {
		storeToRedis(res)
	}

	if !fast {
		printStreamStats()
	}
}

func scheduleJobs(s *gocron.Scheduler) {
	// È´òÈ¢ëÔºö11:00‚Äì13:59 ÊØè 3 ÂàÜÈíü
	_, _ = s.Cron("*/3 11-13 * * *").Do(func() { scheduledTask(true) })
	// È´òÈ¢ëÔºö14:00‚Äì14:30 ÊØè 3 ÂàÜÈíü
	_, _ = s.Cron("0-30/3 14 * * *").Do(func() { scheduledTask(true) })
	// Â∏∏ËßÑÔºö15:15‚Äì22:15 ÊØèÂ∞èÊó∂
	_, _ = s.Cron("15 15-22 * * *").Do(func() { scheduledTask(false) })
}

/* ======================= main ======================= */

func main() {
	// ÂÅ•Â∫∑Ê£ÄÊü•
	if err := redisClient.Set(ctx, "connection_test", "ok", time.Minute).Err(); err != nil {
		log.Fatalf("‚ùå Redis ÂÜôÂÖ•Â§±Ë¥•: %v", err)
	}
	if v, _ := redisClient.Get(ctx, "connection_test").Result(); v != "ok" {
		log.Fatalf("‚ùå Redis ËØªÂÜôÊ†°È™åÂ§±Ë¥•, got=%s", v)
	}
	log.Println("‚úÖ Redis ËØªÂÜô OK")

	initStreamConsumerGroup()

	s := gocron.NewScheduler(time.FixedZone("Asia/Shanghai", 8*3600))
	scheduleJobs(s)

	fmt.Println("ÂÆπÂô®ÂêØÂä®ÔºåÁ´ãÂç≥ÊâßË°åÊäìÂèñ‰ªªÂä°ÔºàÂ∏∏ËßÑÔºâ...")
	scheduledTask(false)
	fmt.Println("ÊäìÂèñÂêéÊâìÂç∞ÈááÊ†∑Ôºö")
	debugRedisData()

	fmt.Println("Ë∞ÉÂ∫¶Âô®ÂêØÂä®ÔºåÁ≠âÂæÖ‰ªªÂä°...")
	fmt.Println("üí° Redis ÂëΩ‰ª§ÔºöXLEN new_matches_stream | XRANGE new_matches_stream - + COUNT 5 | XINFO GROUPS new_matches_stream")
	s.StartBlocking()
}
